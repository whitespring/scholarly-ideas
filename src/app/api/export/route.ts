import { NextRequest, NextResponse } from "next/server";
import jsPDF from "jspdf";

// Type definitions for session data
interface Message {
  role: "user" | "assistant" | "system";
  content: string;
  timestamp: string;
  metadata?: {
    analysisTriggered?: boolean;
    literatureQueried?: boolean;
    feedbackLevel?: number;
    phase?: string;
  };
}

interface FileReference {
  id: string;
  name: string;
  type: string;
  size: number;
  uploadedAt: string;
  summary?: string;
}

interface AnalysisResult {
  type: string;
  summary: string;
  details?: Record<string, unknown>;
  rigorWarnings?: string[];
}

interface LiteratureResult {
  paperId: string;
  title: string;
  authors: string[];
  year: number;
  abstract?: string;
  citationCount?: number;
  url?: string;
  isFromOutsideDiscipline?: boolean;
  discipline?: string;
}

interface PuzzleArtifact {
  type: "statement" | "introduction" | "brief";
  content: string;
  version: number;
  createdAt: string;
}

interface SessionData {
  id: string;
  mode: "idea" | "data" | "exploring";
  subfield?: string;
  messages: Message[];
  uploadedFiles: FileReference[];
  analysisResults: AnalysisResult[];
  literatureFindings: LiteratureResult[];
  puzzleArtifacts: PuzzleArtifact[];
  settings: {
    beDirectMode: boolean;
    teachMeMode: boolean;
  };
  currentPhase: string;
  feedbackEscalation: number;
  createdAt: string;
  lastModified: string;
}

// Helper to generate PDF from session data
function generatePDF(session: SessionData): Buffer {
  const doc = new jsPDF({
    orientation: "portrait",
    unit: "mm",
    format: "a4",
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const contentWidth = pageWidth - 2 * margin;
  let yPos = margin;

  // Helper function to add text with word wrap
  const addWrappedText = (text: string, fontSize: number, isBold: boolean = false) => {
    doc.setFontSize(fontSize);
    doc.setFont("helvetica", isBold ? "bold" : "normal");
    const lines = doc.splitTextToSize(text, contentWidth);
    const lineHeight = fontSize * 0.4;

    for (const line of lines) {
      if (yPos + lineHeight > pageHeight - margin) {
        doc.addPage();
        yPos = margin;
      }
      doc.text(line, margin, yPos);
      yPos += lineHeight;
    }
    yPos += 2;
  };

  // Title
  doc.setFontSize(24);
  doc.setFont("helvetica", "bold");
  doc.setTextColor(30, 58, 138);
  doc.text("Scholarly Ideas", margin, yPos);
  yPos += 12;

  // Session Info
  doc.setFontSize(12);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(100, 100, 100);
  doc.text(`Session: ${session.mode} mode`, margin, yPos);
  yPos += 6;
  if (session.subfield) {
    doc.text(`Subfield: ${session.subfield}`, margin, yPos);
    yPos += 6;
  }
  doc.text(`Exported: ${new Date().toLocaleString()}`, margin, yPos);
  yPos += 10;

  // Reset text color
  doc.setTextColor(0, 0, 0);

  // Conversation
  if (session.messages.length > 0) {
    doc.setFontSize(16);
    doc.setFont("helvetica", "bold");
    doc.text("Conversation", margin, yPos);
    yPos += 8;

    for (const message of session.messages) {
      const roleLabel = message.role === "user" ? "You" : "Assistant";
      addWrappedText(`${roleLabel}: ${message.content}`, 10);
      yPos += 3;
    }
  }

  // Generated Outputs
  if (session.puzzleArtifacts.length > 0) {
    yPos += 5;
    doc.setFontSize(16);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(30, 58, 138);
    doc.text("Generated Outputs", margin, yPos);
    yPos += 8;
    doc.setTextColor(0, 0, 0);

    for (const artifact of session.puzzleArtifacts) {
      const typeLabel = artifact.type === "statement" ? "Puzzle Statement" :
                       artifact.type === "introduction" ? "Introduction Draft" :
                       artifact.type === "brief" ? "Research Brief" : artifact.type;

      doc.setFontSize(12);
      doc.setFont("helvetica", "bold");
      doc.text(`${typeLabel} (v${artifact.version})`, margin, yPos);
      yPos += 6;
      addWrappedText(artifact.content, 10);
      yPos += 5;
    }
  }

  // Footer on all pages
  const pageCount = doc.internal.pages.length - 1;
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(150, 150, 150);
    doc.text(
      `Page ${i} of ${pageCount} | Generated by Scholarly Ideas`,
      pageWidth / 2,
      pageHeight - 10,
      { align: "center" }
    );
  }

  // Return as buffer
  return Buffer.from(doc.output("arraybuffer"));
}

// POST /api/export - Export session data (JSON or PDF)
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { session, format = "json", outputsOnly = false } = body as {
      session: SessionData;
      format?: "json" | "pdf";
      outputsOnly?: boolean;
    };

    if (!session) {
      return NextResponse.json(
        { error: "Session data is required" },
        { status: 400 }
      );
    }

    // Prepare export data
    const exportData = outputsOnly
      ? {
          puzzleArtifacts: session.puzzleArtifacts,
          exportedAt: new Date().toISOString(),
          version: "1.0",
        }
      : {
          ...session,
          exportedAt: new Date().toISOString(),
          version: "1.0",
        };

    if (format === "pdf") {
      // Generate PDF
      const pdfBuffer = generatePDF(session);

      return new NextResponse(new Uint8Array(pdfBuffer), {
        status: 200,
        headers: {
          "Content-Type": "application/pdf",
          "Content-Disposition": `attachment; filename="scholarly-ideas-session-${new Date().toISOString().slice(0, 10)}.pdf"`,
        },
      });
    }

    // Return JSON
    return NextResponse.json(exportData, {
      status: 200,
      headers: {
        "Content-Disposition": `attachment; filename="scholarly-ideas-session-${new Date().toISOString().slice(0, 10)}.json"`,
      },
    });
  } catch (error) {
    console.error("Export error:", error);
    return NextResponse.json(
      { error: "Failed to export session" },
      { status: 500 }
    );
  }
}

// GET /api/export - Return info about export endpoint
// Note: Sessions are stored client-side, so GET without session data
// returns usage instructions
export async function GET() {
  return NextResponse.json({
    message: "Export endpoint for Scholarly Ideas sessions",
    usage: {
      method: "POST",
      body: {
        session: "Session data object (required)",
        format: "json | pdf (default: json)",
        outputsOnly: "boolean - export only generated outputs (default: false)",
      },
    },
    note: "Sessions are stored client-side. Use the Export button in the app to export your session, or POST session data to this endpoint.",
  });
}
